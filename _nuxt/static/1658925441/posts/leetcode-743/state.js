window.__NUXT__=(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1658925441",layout:"default",error:ak,state:{post:{slug:"leetcode-743",description:"Network Delay Time",title:"LeetCode 743번 문제",tags:"algorithm, leetcode, python, bfs, dijkstra_algorithm",toc:[{id:al,depth:N,text:am},{id:an,depth:N,text:ao},{id:ap,depth:N,text:aq},{id:ar,depth:3,text:as},{id:O,depth:N,text:O}],body:{type:"root",children:[{type:b,tag:P,props:{id:al},children:[{type:b,tag:x,props:{href:"#%EB%AC%B8%EC%A0%9C-%EB%A7%81%ED%81%AC",ariaHidden:H,tabIndex:I},children:[{type:b,tag:c,props:{className:[J,K]},children:[]}]},{type:a,value:am}]},{type:a,value:f},{type:b,tag:"p",props:{},children:[{type:b,tag:x,props:{href:at,rel:[W,X,Y],target:Z},children:[{type:a,value:at}]}]},{type:a,value:f},{type:b,tag:P,props:{id:an},children:[{type:b,tag:x,props:{href:"#%EB%82%98%EC%9D%98-%ED%92%80%EC%9D%B4",ariaHidden:H,tabIndex:I},children:[{type:b,tag:c,props:{className:[J,K]},children:[]}]},{type:a,value:ao}]},{type:a,value:f},{type:b,tag:D,props:{},children:[{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"다익스트라 알고리즘을 구현하여 문제를 해결하였다."}]},{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"모든 노드에 대한 거리를 구하여 리스트 "},{type:b,tag:v,props:{},children:[{type:a,value:_}]},{type:a,value:"에 저장한 상태에서 무한대가 아닌 거리의 최댓값이 이 문제의 정답이 된다.\n"},{type:b,tag:D,props:{},children:[{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"여기선 무한대("},{type:b,tag:v,props:{},children:[{type:a,value:"float('inf')"}]},{type:a,value:") 대신 "},{type:b,tag:v,props:{},children:[{type:a,value:$}]},{type:a,value:"로 설정하였는데, 문제에서 언급된 각 노드의 가중치("},{type:b,tag:v,props:{},children:[{type:a,value:"w"}]},{type:a,value:")의 최댓값이 "},{type:b,tag:v,props:{},children:[{type:a,value:"100"}]},{type:a,value:"이기 때문이다."}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:au,props:{},children:[{type:a,value:f},{type:b,tag:av,props:{},children:[{type:a,value:aw}]},{type:a,value:f},{type:b,tag:Q,props:{markdown:z},children:[{type:a,value:f},{type:b,tag:Q,props:{className:[ax]},children:[{type:b,tag:ay,props:{className:[az,aA]},children:[{type:b,tag:v,props:{},children:[{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aB}]},{type:a,value:aC},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:E}]},{type:a,value:aD},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:E}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:E}]},{type:a,value:aF},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aG}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,aH]},children:[{type:a,value:"MySolution1"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:aI},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aJ}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,aK]},children:[{type:a,value:aL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:aM},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:aN},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:aP}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 그래프 생성"}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:L}]},{type:a,value:aS},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:F},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:G}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:aT},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 문제의 최대 w값이 100이므로 float('inf') 대신 101 설정"}]},{type:a,value:"\n        distance "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:$}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:L}]},{type:a,value:" _ "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:G}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:"range"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"n"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aX},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# k번째 거리를 0으로 초기화"}]},{type:a,value:"\n        distance"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"k"},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:ad}]},{type:a,value:aX},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 우선순위 큐 초기화"}]},{type:a,value:"\n        queue "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"\n        heapq"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:ae},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aY}]},{type:a,value:" queue"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"\n            weight"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:" curr_node "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:aZ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:a_},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:L}]},{type:a,value:F},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:G}]},{type:a,value:a$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"curr_node"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"\n                curr_distance "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ba}]},{type:a,value:" weight\n                \n                "},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 거리를 업데이트할 때만 우선순위 큐에 추가"}]},{type:a,value:"\n                "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:U}]},{type:a,value:" curr_distance "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"\u003C"}]},{type:a,value:" distance"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"\n                    distance"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:" curr_distance\n                    heapq"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:ae},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"curr_distance"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:F},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 거리 리스트의 최댓값이 101이면 모든 노드에 접근할 수 없다는 의미"}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:_},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:U}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:_},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"!="}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:$}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"else"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:z}]},{type:a,value:f}]}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:P,props:{id:ap},children:[{type:b,tag:x,props:{href:"#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",ariaHidden:H,tabIndex:I},children:[{type:b,tag:c,props:{className:[J,K]},children:[]}]},{type:a,value:aq}]},{type:a,value:f},{type:b,tag:"h3",props:{id:ar},children:[{type:b,tag:x,props:{href:"#1-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84",ariaHidden:H,tabIndex:I},children:[{type:b,tag:c,props:{className:[J,K]},children:[]}]},{type:a,value:as}]},{type:a,value:f},{type:b,tag:D,props:{},children:[{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"문제에서 판별해야 하는 사항은 다음과 같다.\n"},{type:b,tag:D,props:{},children:[{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"모든 노드가 신호를 받는 데 걸리는 시간 = 가장 오래 걸리는 노드까지의 (최단) 시간"}]},{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"모든 노드에 도달할 수 있는지 여부 = 모든 노드의 다익스트라 알고리즘 계산 값이 존재하는지의 여부"}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"전반적인 로직은 비슷하지만, 모든 노드까지의 거리에 대해 미리 무한대 값을 할당하는 대신, "},{type:b,tag:v,props:{},children:[{type:a,value:V}]},{type:a,value:" 딕셔너리의 키(노드) 존재 유무를 통해 노드의 거리를 판단한다. 즉, "},{type:b,tag:v,props:{},children:[{type:a,value:V}]},{type:a,value:"에 키가 존재하지 않으면 해당 노드까지의 거리는 무한대이며, 키가 존재하면 그 값이 해당 노드까지의 거리가 된다."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:au,props:{},children:[{type:a,value:f},{type:b,tag:av,props:{},children:[{type:a,value:aw}]},{type:a,value:f},{type:b,tag:Q,props:{markdown:z},children:[{type:a,value:f},{type:b,tag:Q,props:{className:[ax]},children:[{type:b,tag:ay,props:{className:[az,aA]},children:[{type:b,tag:v,props:{},children:[{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aB}]},{type:a,value:aC},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:E}]},{type:a,value:aD},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:E}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:E}]},{type:a,value:aF},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aG}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,aH]},children:[{type:a,value:"Solution1"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:aI},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aJ}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,aK]},children:[{type:a,value:aL}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:aM},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:aN},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:aP}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:L}]},{type:a,value:aS},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:F},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:G}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:aT},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 큐 변수: [(소요 시간, 정점)]"}]},{type:a,value:"\n        Q "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 거리를 저장하는 dist 변수는 초깃값을 무한대로 모두 설정하는 대신"}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 초깃값이 0인 딕셔너리(defaultdict)로 초기화"}]},{type:a,value:"\n        dist "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:w}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 우선순위 큐 최솟값 기준으로 정점까지 최단 경로 삽입"}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aY}]},{type:a,value:" Q"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"\n            time"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:bb},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:aZ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:a_},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bc},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\n            "},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# dist에 해당 노드가 존재하지 않음 = 해당 노드까지의 거리가 무한대"}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:U}]},{type:a,value:bb},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"not"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:G}]},{type:a,value:" dist"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"\n                dist"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bd},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:" time\n                "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:L}]},{type:a,value:F},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:G}]},{type:a,value:a$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:bd},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"\n                    alt "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:q}]},{type:a,value:" time "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ba}]},{type:a,value:" w\n                    heapq"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:ae},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bc},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"alt"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:F},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,r]},children:[{type:a,value:"# 모든 노드의 최단 경로를 구한 경우 dist의 노드 개수가 n개 존재"}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:U}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:"len"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:V},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"=="}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:V},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:"values"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,u]},children:[{type:a,value:z}]},{type:a,value:f}]}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:P,props:{id:O},children:[{type:b,tag:x,props:{href:"#%EC%B6%9C%EC%B2%98",ariaHidden:H,tabIndex:I},children:[{type:b,tag:c,props:{className:[J,K]},children:[]}]},{type:a,value:O}]},{type:a,value:f},{type:b,tag:D,props:{},children:[{type:a,value:f},{type:b,tag:t,props:{},children:[{type:a,value:"박상길, 『파이썬 알고리즘 인터뷰』, 책만(2020), p373-378.\n"},{type:b,tag:D,props:{},children:[{type:a,value:f},{type:b,tag:t,props:{},children:[{type:b,tag:x,props:{href:"https:\u002F\u002Fwww.onlybook.co.kr\u002Fentry\u002Falgorithm-interview",rel:[W,X,Y],target:Z},children:[{type:a,value:"도서 정보"}]}]},{type:a,value:f},{type:b,tag:t,props:{},children:[{type:b,tag:x,props:{href:"https:\u002F\u002Fgithub.com\u002Fonlybooks\u002Falgorithm-interview",rel:[W,X,Y],target:Z},children:[{type:a,value:"GitHub"}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f}]}]},text:"\n## 문제 링크\n\nhttps:\u002F\u002Fleetcode.com\u002Fproblems\u002Fnetwork-delay-time\u002F\n\n## 나의 풀이\n\n- 다익스트라 알고리즘을 구현하여 문제를 해결하였다.\n- 모든 노드에 대한 거리를 구하여 리스트 `distance`에 저장한 상태에서 무한대가 아닌 거리의 최댓값이 이 문제의 정답이 된다.\n  - 여기선 무한대(`float('inf')`) 대신 `101`로 설정하였는데, 문제에서 언급된 각 노드의 가중치(`w`)의 최댓값이 `100`이기 때문이다.\n\n\u003Cdetails\u003E\n\u003Csummary\u003E소스 코드\u003C\u002Fsummary\u003E\n\u003Cdiv markdown=\"1\"\u003E\n\n```python\nfrom typing import List\nimport collections\nimport heapq\n\n\nclass MySolution1:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003E int:\n        # 그래프 생성\n        graph = collections.defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((v, w))\n\n        # 문제의 최대 w값이 100이므로 float('inf') 대신 101 설정\n        distance = [101 for _ in range(n)]\n        \n        # k번째 거리를 0으로 초기화\n        distance[k-1] = 0\n        \n        # 우선순위 큐 초기화\n        queue = []\n        heapq.heappush(queue, (0, k))\n\n        while queue:\n            weight, curr_node = heapq.heappop(queue)\n            for v, w in graph[curr_node]:\n                curr_distance = w + weight\n                \n                # 거리를 업데이트할 때만 우선순위 큐에 추가\n                if curr_distance \u003C distance[v-1]:\n                    distance[v-1] = curr_distance\n                    heapq.heappush(queue, (curr_distance, v))\n\n        # 거리 리스트의 최댓값이 101이면 모든 노드에 접근할 수 없다는 의미\n        return max(distance) if max(distance) != 101 else -1\n```\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdetails\u003E\n\n## 문제 풀이\n\n### 1. 다익스트라 알고리즘 구현\n\n- 문제에서 판별해야 하는 사항은 다음과 같다.\n  - 모든 노드가 신호를 받는 데 걸리는 시간 = 가장 오래 걸리는 노드까지의 (최단) 시간\n  - 모든 노드에 도달할 수 있는지 여부 = 모든 노드의 다익스트라 알고리즘 계산 값이 존재하는지의 여부\n- 전반적인 로직은 비슷하지만, 모든 노드까지의 거리에 대해 미리 무한대 값을 할당하는 대신, `dist` 딕셔너리의 키(노드) 존재 유무를 통해 노드의 거리를 판단한다. 즉, `dist`에 키가 존재하지 않으면 해당 노드까지의 거리는 무한대이며, 키가 존재하면 그 값이 해당 노드까지의 거리가 된다.\n\n\u003Cdetails\u003E\n\u003Csummary\u003E소스 코드\u003C\u002Fsummary\u003E\n\u003Cdiv markdown=\"1\"\u003E\n\n```python\nfrom typing import List\nimport collections\nimport heapq\n\n\nclass Solution1:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003E int:\n        graph = collections.defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((v, w))\n\n        # 큐 변수: [(소요 시간, 정점)]\n        Q = [(0, k)]\n\n        # 거리를 저장하는 dist 변수는 초깃값을 무한대로 모두 설정하는 대신\n        # 초깃값이 0인 딕셔너리(defaultdict)로 초기화\n        dist = collections.defaultdict(int)\n\n        # 우선순위 큐 최솟값 기준으로 정점까지 최단 경로 삽입\n        while Q:\n            time, node = heapq.heappop(Q)\n\n            # dist에 해당 노드가 존재하지 않음 = 해당 노드까지의 거리가 무한대\n            if node not in dist:\n                dist[node] = time\n                for v, w in graph[node]:\n                    alt = time + w\n                    heapq.heappush(Q, (alt, v))\n\n        # 모든 노드의 최단 경로를 구한 경우 dist의 노드 개수가 n개 존재\n        if len(dist) == n:\n            return max(dist.values())\n        return -1\n```\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdetails\u003E\n\n## 출처\n\n- 박상길, 『파이썬 알고리즘 인터뷰』, 책만(2020), p373-378.\n  - [도서 정보](https:\u002F\u002Fwww.onlybook.co.kr\u002Fentry\u002Falgorithm-interview)\n  - [GitHub](https:\u002F\u002Fgithub.com\u002Fonlybooks\u002Falgorithm-interview)\n",dir:"\u002Fposts\u002F2021\u002F06\u002F03",path:"\u002Fposts\u002F2021\u002F06\u002F03\u002Fleetcode-743",extension:".md",createdAt:"2021-06-03T14:40:17.000Z",updatedAt:"2022-06-26T10:01:49.000Z"},isErrorPage:C,isDarkMode:C,isScrolled:C,isMobile:C,isTablet:C,hasHeaderImage:aj,isMobileMenuOpened:C,headerImage:"",perPage:10},serverRendered:aj,routePath:"\u002Fposts\u002Fleetcode-743",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:ak},content:{dbHash:"02e4aae2"}},colorMode:{preference:be,value:be,unknown:aj,forced:C}}}("text","element","span","token","punctuation","\n"," ","keyword","operator","(",")",",",":","builtin","[","]","=","comment",".","li","number","code","int","a","\n        ","1","-","\n\n        ",false,"ul","import"," v","in","true",-1,"icon","icon-link","for"," w ",2,"출처","h2","div"," times"," k","v","if","dist","nofollow","noopener","noreferrer","_blank","distance","101"," n"," collections","defaultdict","0","heappush","queue","\n            ","return","max",true,null,"문제-링크","문제 링크","나의-풀이","나의 풀이","문제-풀이","문제 풀이","1-다익스트라-알고리즘-구현","1. 다익스트라 알고리즘 구현","https:\u002F\u002Fleetcode.com\u002Fproblems\u002Fnetwork-delay-time\u002F","details","summary","소스 코드","nuxt-content-highlight","pre","language-python","line-numbers","from"," typing "," List\n"," collections\n"," heapq\n\n\n","class","class-name","\n    ","def","function","networkDelayTime","self"," List","List","\u003E","\n        graph ","list"," u","\n            graph","u","append"," w","\n        \n        ","while"," heapq","heappop"," graph","+"," node ","Q","node","system"));