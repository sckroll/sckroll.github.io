---
title: "SWEA 1233번 문제: 사칙연산 유효성 검사"
description: SWEA 1233
tags: algorithm, java, swea, sw_expert_academy, tree
---

## 문제 링크

https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV141176AIwCFAYD&

## 풀이

- 이 문제에서 사칙연산이 유효하지 않는 경우는 다음과 같다.
   1. 피연산자 노드가 자식 노드를 가지고 있는 경우
   2. 연산자 노드가 리프 노드인 경우
      - 연산자 노드가 자식 노드를 가지고 있어도, 왼쪽 자식이 숫자이고, 오른쪽 자식이 연산자일 경우
        - 이 조건이 없어도 테스트 케이스는 통과하지만, 문제에서 완전 이진 트리 조건이 없다면 이 조건도 포함해야 한다.
        - 왼쪽부터 자식 노드가 추가되는 특성 때문에 이 조건이 붙은 것으로 보인다.
- 사칙연산이 유효하지 않는 조건을 따로 분기하고, 해당되는 경우 `result` 값을 `0`으로 설정 후 이후에 읽어오는 모든 라인을 `continue`로 패스한다. 초기화를 진행한 후에 로직을 수행하는 것이 아니라, 초기화를 진행하면서 로직을 수행하기 때문이다.
- 첫 번째 노드부터 `n/2` 노드까지는 연산자이고, 그 이후 노드는 피연산자라는 공식을 사용해서 풀 수도 있다.
  - 단, `n`이 짝수이면 마지막 노드의 자식 노드가 홀수이므로 이 부분을 고려해야 한다.

<details>
<summary>소스 코드</summary>
<div markdown="1">

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;

/**
 * SW Expert Academy 1233번 문제: 사칙연산 유효성 검사
 */
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        
        int T = 10;
        Set<Character> operand = new HashSet<>(Arrays.asList('+', '-', '*', '/'));
      
        for (int tc = 1; tc <= T; tc++) {
            int n = Integer.parseInt(br.readLine());
            int result = 1;
            
            for (int i = 1; i <= n; i++) {
                // 이미 계산이 불가능하다고 판단된 경우 루프가 끝날 때까지 라인 읽기만 수행
                if (result == 0) {
                    br.readLine();
                    continue;
                }
                
                st = new StringTokenizer(br.readLine());
                st.nextToken();
                char op = st.nextToken().charAt(0);
                
                if (st.hasMoreTokens()) {
                    // 서브 트리의 루트 노드가 피연산자일 경우 0
                    if (!operand.contains(op)) {
                        result = 0;
                        continue;
                    }
                    char left = st.nextToken().charAt(0);
                    
                    // 자식 노드가 하나만 있는 경우 0
                    if (!st.hasMoreTokens()) {
                        result = 0;
                        continue;
                    }
                    char right = st.nextToken().charAt(0);
                    
                    // 왼쪽 자식 노드가 숫자이고, 오른쪽 자식 노드가 연산자이면 0
                    if (!operand.contains(left) && operand.contains(right)) {
                        result = 0;
                    }
                } else {
                    // 리프 노드가 연산자일 경우 0
                    if (operand.contains(op)) {
                        result = 0;
                        continue;
                    }
                }
            }
          
            System.out.println("#" + tc + " " + result);
        }
      
        br.close();
    }
}
```

</div>
</details>
