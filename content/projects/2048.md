---
title: 2048
description: 2048 게임을 클론하여 구현한 프로젝트
image: 2048/main.png
period: 2021. 09. 03. ~ 2021. 09. 22. (약 3주)
stacks: [JavaScript (Vanilla JS)]
isTeamProject: false
---

## 개요

유명한 [2048 게임](https://play2048.co/)을 클론하여 저만의 방식으로 만들어보았습니다. GitHub에 올라온 해당 게임의 리포지토리 등 2048에 관련된 소스코드를 참고하지 않고 스스로 알고리즘을 구현했으며, 원작에는 없는 일부 기능을 추가하였습니다. 별도의 프레임워크 없이 Vanilla JS로 구현했으며, JS로 직접 DOM을 다뤄보고 싶어서 초기 HTML의 구조는 싱글 페이지 애플리케이션(SPA)의 구조를 모방하였습니다.

## 주요 기능

### 전체 구조

![앱 구조](/images/projects/2048/structure.png)

### 알고리즘

게임의 전체적인 흐름은 다음과 같습니다.

![게임의 흐름](/images/projects/2048/flow.png)

키보드 혹은 화면 슬라이드에 따라 블록(타일)을 이동시킬 때, 이동 방향에 따라 현재 블록 정보가 담긴 2차원 배열(이하 '행렬')을 변형시킨 후, 각 행에 대해 알고리즘을 적용하고 다시 원래 모습으로 변형시켜서 사용합니다.

- 아래 -> 위로 이동: 기존 행렬을 왼쪽으로 90도 회전한 형태, 즉 행렬의 행과 열을 스왑 후 행의 순서를 뒤집은 상태
  ![아래에서 위로](/images/projects/2048/matrix-up.png)
- 위 -> 아래로 이동: 기존 행렬을 오른쪽으로 90도 회전한 형태, 즉 행렬의 행과 열을 스왑한 상태
  ![위에서 아래로](/images/projects/2048/matrix-down.png)
- 오른쪽 -> 왼쪽으로 이동: 기존 행렬을 좌우 반전한 형태, 즉 행렬의 열 순서를 뒤집은 상태
  ![오른쪽에서 왼쪽으로](/images/projects/2048/matrix-left.png)
- 왼쪽 -> 오른쪽으로 이동: 기존 행렬 그대로의 상태
  ![왼쪽에서 오른쪽으로](/images/projects/2048/matrix-right.png)

이동 방향에 맞게 행렬을 변형시켰으면, 각 행에 대해 블록을 이동하거나 병합 혹은 삭제하는 알고리즘을 적용합니다. 가장 오른쪽(마지막) 인덱스부터 '기준'을 잡고 기준 인덱스를 줄여가며 그 왼쪽에 있는 모든 값('검사 대상')을 거꾸로 순회합니다. 다음과 같이 세 가지의 경우로 나누었습니다.

1. 검사 대상이 `0`이면, 다음 검사 대상으로
   ![첫 번째 경우](/images/projects/2048/case-1.png)
2. 검사 대상이 기준과 같은 값이면, 그 위치의 값을 `0`으로 설정 후, 기준의 값은 `2`배로 설정 & 현재 기준을 끝내고 다음 기준으로
   ![두 번째 경우](/images/projects/2048/case-2.png)
3. 검사 대상이 그 외의 값이면 현재 기준을 끝내고 다음 기준으로
   ![세 번째 경우](/images/projects/2048/case-3.png)
   - 단, 기준의 값이 `0`이면 기준과 검사 대상의 값을 스왑한 후 다음 검사 대상으로
      ![세 번째 경우 추가 1](/images/projects/2048/case-3-1.png)
      ![세 번째 경우 추가 2](/images/projects/2048/case-3-2.png)

### 현재 점수, 최고 점수, 현재 턴 표시

![현재 점수, 최고 점수, 현재 턴](/images/projects/2048/score-turn.png)

각 턴마다 현재 점수(`Score`)와 턴(`Turn`)을 업데이트하도록 했으며, 최고 점수(`High Score`)의 경우 기존 최고 기록을 경신한 경우에만 로컬 스토리지(`localStorage`)에 저장됩니다. 이렇게 저장된 최고 기록 데이터는 게임을 시작할 때마다 로컬 스토리지로부터 불러와 사용되며, 게임을 맨 처음 시작하는 경우와 같이 로컬 스토리지에 데이터가 없는 경우 `0`으로 초기화됩니다.

### 방향 키와 화면 슬라이드로 블록 이동

키보드 방향 키로 블록을 이동시킬 수 있지만, 원하는 방향으로 화면을 슬라이드하여 이동시킬 수도 있습니다. 슬라이드 조작은 데스크탑과 모바일 환경을 모두 지원합니다. 키 입력은 `keydown` 이벤트로 받았으며, 마우스 슬라이드(드래그)는 `mousedown`, `mouseup`, `mousemove` 이벤트를 사용했습니다. 하지만 모바일 환경에서는 마우스 이벤트가 동작하지 않아 별도의 터치 입력을 받는 `touchstart`, `touchend`, `touchmove` 이벤트를 받아서 사용했습니다.

### 다크 모드

![다크 모드](/images/projects/2048/darkmode.png)

`prefers-color-scheme` 미디어 쿼리로 시스템 다크 모드 여부를 판단하여 앱을 열자마자 다크 모드를 적용하며, 하단의 토글 버튼으로 다크 모드를 설정하거나 해제할 수 있습니다.

### 로그 기능

![로그 화면](/images/projects/2048/log-1.png)
<p align="center">▲ 로그 화면</p>

![로그 툴팁](/images/projects/2048/log-2.png)
<p align="center">▲ 로그 툴팁</p>

로그 토글 버튼을 클릭하여 로그 화면을 표시하거나 끌 수 있습니다. 지금까지 사용자가 이동한 방향, 이전 턴, 해당 턴에서 획득한 점수, 이전 턴의 블록 배치 상태를 확인할 수 있으며, 특히 블록 배치 상태는 아이콘에 마우스를 올리면 툴팁 형식으로 블록 배치 상태를 확인할 수 있습니다.

(사실 그렇게 쓸모있는 기능은 아닙니다만...)

### 반응형 디자인

|![데스크탑 화면](/images/projects/2048/desktop.png)|![모바일 화면](/images/projects/2048/mobile.png)|
|---|---|
|▲ 데스크탑 화면|▲ 모바일 화면|

미디어 쿼리를 사용하여 특정 너비 이하일 경우 각 요소의 스타일을 조정하여 모바일 환경에서도 게임을 즐길 수 있도록 만들었습니다.

## 느낀 점

간단한 게임이니만큼 빠른 시간 내에 구현할 수 있다고 나름 자신했지만, 생각보다 쉬운 일이 아니었습니다. 밑바닥부터 하나하나 만들어가면서 게임 알고리즘에 대해 탐구하고, 이를 어떻게 화면에 출력할 것인지, 그리고 어떻게 하면 효율적으로 코드를 작성할 수 있는지 고민해야 했습니다. Vue와 같은 프레임워크에 익숙해진 상태로 이를 구현하려다 보니 평소보다 많은 고민을 해야 했지만, 그만큼 배운 점도 많았다고 생각합니다. 특히 맨 처음 하나의 DOM부터 시작해서 다른 DOM을 붙여가며 화면에 렌더링하는 과정을 직접 구현해보면서 SPA가 어떻게 동작하는지 이해할 수 있었고, 키보드나 터치 이벤트 핸들러를 연결했을 때, `this`가 올바르게 바인딩되지 않았을 경우에 대처하는 방법을 배웠숩니다.

기능 구현에 집중하느라 리팩토링까지 끝낸 완벽한 코드라고 할 수 없지만, 다양한 추가 기능을 구현하면서 제가 잊고 있거나 모르고 있던 다양한 지식을 습득할 수 있어서 좋은 기회였습니다. 다음 프로젝트도 Vanilla JS로 만들지는 미지수지만, 적어도 이번 프로젝트에서 배운 내용을 이후에도 유용하게 사용할 것 같습니다.

## 링크

- 앱 URL: https://sckroll-2048.netlify.app
- GitHub: https://github.com/sckroll/sckroll-2048
