__NUXT_JSONP__("/posts/leetcode-208", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE){ae.slug="leetcode-208";ae.description="Implement Trie (Prefix Tree)";ae.title="LeetCode 208번 문제";ae.tags="algorithm, leetcode, python, trie";ae.toc=[{id:af,depth:H,text:ag},{id:ah,depth:H,text:ai},{id:aj,depth:H,text:ak},{id:al,depth:3,text:am},{id:I,depth:H,text:I}];ae.body={type:"root",children:[{type:b,tag:J,props:{id:af},children:[{type:b,tag:n,props:{href:"#%EB%AC%B8%EC%A0%9C-%EB%A7%81%ED%81%AC",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:ag}]},{type:a,value:f},{type:b,tag:"p",props:{},children:[{type:b,tag:n,props:{href:an,rel:[O,P,Q],target:R},children:[{type:a,value:an}]}]},{type:a,value:f},{type:b,tag:J,props:{id:ah},children:[{type:b,tag:n,props:{href:"#%EB%82%98%EC%9D%98-%ED%92%80%EC%9D%B4-%ED%92%80%EC%9D%B4-%EC%8B%A4%ED%8C%A8",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:ai}]},{type:a,value:f},{type:b,tag:K,props:{},children:[{type:a,value:f},{type:b,tag:o,props:{},children:[{type:a,value:"처음 접해보는 자료구조라 구현 방법을 다소 참고할 수 밖에 없었다."}]},{type:a,value:f},{type:b,tag:o,props:{},children:[{type:a,value:"참고해서 구현했지만 책에서 나온 풀이법과 다를 바가 없으므로 풀이법은 생략하였다."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:J,props:{id:aj},children:[{type:b,tag:n,props:{href:"#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:ak}]},{type:a,value:f},{type:b,tag:"h3",props:{id:al},children:[{type:b,tag:n,props:{href:"#1-%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EA%B0%84%EA%B2%B0%ED%95%9C-%ED%8A%B8%EB%9D%BC%EC%9D%B4-%EA%B5%AC%ED%98%84",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:am}]},{type:a,value:f},{type:b,tag:K,props:{},children:[{type:a,value:f},{type:b,tag:o,props:{},children:[{type:a,value:"트라이는 다진 트리(m-ary Tree)이기 때문에 이진 트리처럼 "},{type:b,tag:L,props:{},children:[{type:a,value:"left"}]},{type:a,value:"와 "},{type:b,tag:L,props:{},children:[{type:a,value:"right"}]},{type:a,value:"를 나눌 필요 없이 딕셔너리 하나로 자식 노드를 관리할 수 있다."}]},{type:a,value:f},{type:b,tag:o,props:{},children:[{type:a,value:"일반 딕셔너리 대신 "},{type:b,tag:L,props:{},children:[{type:a,value:ao}]},{type:a,value:"를 사용하면 코드를 더 줄일 수 있다."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:"details",props:{},children:[{type:a,value:f},{type:b,tag:"summary",props:{},children:[{type:a,value:"소스 코드"}]},{type:a,value:f},{type:b,tag:ap,props:{markdown:"1"},children:[{type:a,value:f},{type:b,tag:ap,props:{className:["nuxt-content-highlight"]},children:[{type:b,tag:"pre",props:{className:["language-python","line-numbers"]},children:[{type:b,tag:L,props:{},children:[{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:"import"}]},{type:a,value:" collections\n\n\n"},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 트라이를 저장할 노드를 별도의 클래스로 선언"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aq}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,ar]},children:[{type:a,value:as}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:z}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 현재 노드까지 연결했을 때 단어가 완성되는 경우 True"}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:au},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:T}]},{type:a,value:"\n        \n        "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 자식 노드를 저장하는 딕셔너리"}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# self.children = {}"}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:"children "},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:" collections"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:ao},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:"\n\n\n"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aq}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,ar]},children:[{type:a,value:"Trie"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:z}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:"root "},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:" TrieNode"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:av},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 트라이에 단어 삽입"}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:z}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"insert"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:U}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,D]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:X}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"None"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:aw},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:_}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:F}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:r},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 해당하는 자식 노드가 없으면 노드를 새로 생성"}]},{type:a,value:r},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# if char not in node.children:"}]},{type:a,value:r},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"#     node.children[char] = TrieNode()"}]},{type:a,value:"\n                \n            "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:$}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:t},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:ab}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:ad}]},{type:a,value:ax},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 단어가 추가되었으므로 단어 여부를 True로 설정"}]},{type:a,value:"\n        node"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:au},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:ay}]},{type:a,value:av},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 단어 검색"}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:z}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"search"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:U}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,D]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:X}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,D]},children:[{type:a,value:az}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:"root\n        \n        "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:_}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:F}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:r},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 해당하는 자식 노드가 없으면 단어가 존재하지 않다는 의미"}]},{type:a,value:r},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aA}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aB}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:F}]},{type:a,value:t},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aC},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:N}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:T}]},{type:a,value:aD},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:$}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:t},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:ab}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:ad}]},{type:a,value:"\n            \n        "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 마지막 노드의 word 속성이 True면 찾고자 하는 단어가 존재한다는 뜻"}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:N}]},{type:a,value:t},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:"word\n\n    "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 해당 문자열로 시작하는 단어가 있는지 여부 판별 (단어 검색 메소드의 로직과 비슷)"}]},{type:a,value:y},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:z}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:"startsWith"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:B},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:U}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,D]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:X}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,D]},children:[{type:a,value:az}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:aw},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:_}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:F}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:r},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 해당하는 자식 노드가 없으면 prefix로 시작하는 단어가 존재하지 않다는 의미"}]},{type:a,value:r},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aA}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aB}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:F}]},{type:a,value:t},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aC},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:N}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:T}]},{type:a,value:aD},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:$}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:m}]},{type:a,value:t},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:ab}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:ad}]},{type:a,value:ax},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 단어 검색과 달리 단어 자체가 존재하는지 판단하는 게 아니라"}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"# 자식 노드가 존재하는지 여부만 판별하기 때문에 True 반환"}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:N}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:ay}]},{type:a,value:f}]}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:J,props:{id:I},children:[{type:b,tag:n,props:{href:"#%EC%B6%9C%EC%B2%98",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:I}]},{type:a,value:f},{type:b,tag:K,props:{},children:[{type:a,value:f},{type:b,tag:o,props:{},children:[{type:a,value:"박상길, 『파이썬 알고리즘 인터뷰』, 책만(2020), p459-465.\n"},{type:b,tag:K,props:{},children:[{type:a,value:f},{type:b,tag:o,props:{},children:[{type:b,tag:n,props:{href:"https:\u002F\u002Fwww.onlybook.co.kr\u002Fentry\u002Falgorithm-interview",rel:[O,P,Q],target:R},children:[{type:a,value:"도서 정보"}]}]},{type:a,value:f},{type:b,tag:o,props:{},children:[{type:b,tag:n,props:{href:"https:\u002F\u002Fgithub.com\u002Fonlybooks\u002Falgorithm-interview",rel:[O,P,Q],target:R},children:[{type:a,value:"GitHub"}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f}]}]};ae.text="\n## 문제 링크\n\nhttps:\u002F\u002Fleetcode.com\u002Fproblems\u002Fimplement-trie-prefix-tree\u002F\n\n## 나의 풀이 (풀이 실패)\n\n- 처음 접해보는 자료구조라 구현 방법을 다소 참고할 수 밖에 없었다.\n- 참고해서 구현했지만 책에서 나온 풀이법과 다를 바가 없으므로 풀이법은 생략하였다.\n\n## 문제 풀이\n\n### 1. 딕셔너리를 이용해 간결한 트라이 구현\n\n- 트라이는 다진 트리(m-ary Tree)이기 때문에 이진 트리처럼 `left`와 `right`를 나눌 필요 없이 딕셔너리 하나로 자식 노드를 관리할 수 있다.\n- 일반 딕셔너리 대신 `defaultdict`를 사용하면 코드를 더 줄일 수 있다.\n\n\u003Cdetails\u003E\n\u003Csummary\u003E소스 코드\u003C\u002Fsummary\u003E\n\u003Cdiv markdown=\"1\"\u003E\n\n```python\nimport collections\n\n\n# 트라이를 저장할 노드를 별도의 클래스로 선언\nclass TrieNode:\n    def __init__(self):\n        # 현재 노드까지 연결했을 때 단어가 완성되는 경우 True\n        self.word = False\n        \n        # 자식 노드를 저장하는 딕셔너리\n        # self.children = {}\n        self.children = collections.defaultdict(TrieNode)\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    # 트라이에 단어 삽입\n    def insert(self, word: str) -\u003E None:\n        node = self.root\n\n        for char in word:\n            # 해당하는 자식 노드가 없으면 노드를 새로 생성\n            # if char not in node.children:\n            #     node.children[char] = TrieNode()\n                \n            # 노드 위치 갱신\n            node = node.children[char]\n\n        # 단어가 추가되었으므로 단어 여부를 True로 설정\n        node.word = True\n\n    # 단어 검색\n    def search(self, word: str) -\u003E bool:\n        node = self.root\n        \n        for char in word:\n            # 해당하는 자식 노드가 없으면 단어가 존재하지 않다는 의미\n            if char not in node.children:\n                return False\n\n            # 노드 위치 갱신\n            node = node.children[char]\n            \n        # 마지막 노드의 word 속성이 True면 찾고자 하는 단어가 존재한다는 뜻\n        return node.word\n\n    # 해당 문자열로 시작하는 단어가 있는지 여부 판별 (단어 검색 메소드의 로직과 비슷)\n    def startsWith(self, prefix: str) -\u003E bool:\n        node = self.root\n\n        for char in prefix:\n            # 해당하는 자식 노드가 없으면 prefix로 시작하는 단어가 존재하지 않다는 의미\n            if char not in node.children:\n                return False\n\n            # 노드 위치 갱신\n            node = node.children[char]\n\n        # 단어 검색과 달리 단어 자체가 존재하는지 판단하는 게 아니라\n        # 자식 노드가 존재하는지 여부만 판별하기 때문에 True 반환\n        return True\n```\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdetails\u003E\n\n## 출처\n\n- 박상길, 『파이썬 알고리즘 인터뷰』, 책만(2020), p459-465.\n  - [도서 정보](https:\u002F\u002Fwww.onlybook.co.kr\u002Fentry\u002Falgorithm-interview)\n  - [GitHub](https:\u002F\u002Fgithub.com\u002Fonlybooks\u002Falgorithm-interview)\n";ae.dir="\u002Fposts\u002F2021\u002F08\u002F26";ae.path="\u002Fposts\u002F2021\u002F08\u002F26\u002Fleetcode-208";ae.extension=".md";ae.createdAt="2021-08-26T12:39:54.000Z";ae.updatedAt="2022-06-26T10:01:49.000Z";return {data:[{post:ae,prev:{slug:"leetcode-215",title:"LeetCode 215번 문제",createdAt:"2021-08-25T14:56:36.000Z"},next:{slug:"leetcode-336",title:"LeetCode 336번 문제",createdAt:"2021-08-30T14:19:29.000Z"}}],fetch:{},mutations:[["SET_POST",ae],["CLEAR_HEADER_IMAGE",void 0],["SET_HEADER_IMAGE_STATE",true],["SET_SCROLL_STATE",false]]}}("text","element","span","token","punctuation","\n","keyword"," ","comment","operator",":",".","=","a","li","(",")","\n            ","boolean"," node","true",-1,"icon","icon-link","\n    ","def","function","self","\n        ","builtin"," char ","in","children",2,"출처","h2","ul","code"," word","return","nofollow","noopener","noreferrer","_blank","\n        self","False",",","str","-","\u003E","\n        node "," self","for","# 노드 위치 갱신","\n            node ","[","char","]",{},"문제-링크","문제 링크","나의-풀이-풀이-실패","나의 풀이 (풀이 실패)","문제-풀이","문제 풀이","1-딕셔너리를-이용해-간결한-트라이-구현","1. 딕셔너리를 이용해 간결한 트라이 구현","https:\u002F\u002Fleetcode.com\u002Fproblems\u002Fimplement-trie-prefix-tree\u002F","defaultdict","div","class","class-name","TrieNode","__init__","word ","\n\n    ","root\n\n        ","\n\n        ","True","bool","if","not","\n                ","\n\n            "," prefix")));