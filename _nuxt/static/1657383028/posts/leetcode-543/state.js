window.__NUXT__=(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1657383028",layout:"default",error:aw,state:{post:{slug:"leetcode-543",description:"Diameter of Binary Tree",title:"LeetCode 543번 문제",tags:"algorithm, leetcode, python, dfs, tree",toc:[{id:ax,depth:J,text:ay},{id:az,depth:J,text:aA},{id:aB,depth:J,text:aC},{id:aD,depth:aE,text:aF},{id:aG,depth:J,text:aH},{id:aI,depth:aE,text:aJ},{id:P,depth:J,text:P}],body:{type:ab,children:[{type:b,tag:K,props:{id:ax},children:[{type:b,tag:q,props:{href:"#%EB%AC%B8%EC%A0%9C-%EB%A7%81%ED%81%AC",ariaHidden:w,tabIndex:x},children:[{type:b,tag:c,props:{className:[y,z]},children:[]}]},{type:a,value:ay}]},{type:a,value:g},{type:b,tag:"p",props:{},children:[{type:b,tag:q,props:{href:aK,rel:[ac,ad,ae],target:af},children:[{type:a,value:aK}]}]},{type:a,value:g},{type:b,tag:K,props:{id:az},children:[{type:b,tag:q,props:{href:"#%EB%82%98%EC%9D%98-%ED%92%80%EC%9D%B4-%ED%92%80%EC%9D%B4-%EC%8B%A4%ED%8C%A8",ariaHidden:w,tabIndex:x},children:[{type:b,tag:c,props:{className:[y,z]},children:[]}]},{type:a,value:aA}]},{type:a,value:g},{type:b,tag:G,props:{},children:[{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"노드의 값이 모두 다른 경우는 별다른 문제가 없지만, 모든 요소의 값이 똑같을 경우 아래 방법으로 해결할 수 없다."}]},{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"ex: "},{type:b,tag:s,props:{},children:[{type:a,value:"[0, 0, 0, 0, None, None, 0, None, None, None, 0]"}]}]},{type:a,value:g}]},{type:a,value:g},{type:b,tag:aL,props:{},children:[{type:a,value:g},{type:b,tag:aM,props:{},children:[{type:a,value:aN}]},{type:a,value:g},{type:b,tag:Q,props:{markdown:R},children:[{type:a,value:g},{type:b,tag:Q,props:{className:[aO]},children:[{type:b,tag:aP,props:{className:[aQ,aR]},children:[{type:b,tag:s,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:S}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:aS}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:H}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:aT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,V]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,V]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aX},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aZ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:a_},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:a$},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:" right\n\n\n"},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:S}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:"MySolution1"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:H}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:ba},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aj},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ak}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 리프 노드까지의 모든 경로를 routes 리스트에 저장"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:H}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:bb},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:Z}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:" tree"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:Z}]},{type:a,value:" curr_route "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:_}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"\n                    routes"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:bc},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"curr_route"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:N}]},{type:a,value:"\n\n            appended_route "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:bb},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:"\n            appended_route"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:bc},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"val"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bd},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ao},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bd},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:bf},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"\n\n        routes "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:"\n        dfs"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"\n\n        max_length "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:U}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# routes에 존재하는 모든 리프 노드까지의 경로끼리 비교,"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 요소의 값이 달라지는 순간부터 이후의 모든 값의 개수를 합산하면"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 두 리프 노드의 길이(length)가 됨"}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ap}]},{type:a,value:" i "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:_}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:aq}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ap}]},{type:a,value:" j "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:_}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:aq}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"\n                a"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:" b "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:"j"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"print"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:q},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:bi},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"\n\n                "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:ap}]},{type:a,value:" k "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:_}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:aq}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:bj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:q},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"\n                    "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:Z}]},{type:a,value:" a"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:bk},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"!="}]},{type:a,value:bi},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:D}]},{type:a,value:bk},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"\n                        length "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:q},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:B}]},{type:a,value:bl},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aa}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:B}]},{type:a,value:bl},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"\n                        max_length "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bm},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:bn},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 리프 노드가 하나만 있을 경우를 위해"}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 두 노드의 최대 거리를 계산"}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# ex: [1, 2]"}]},{type:a,value:"\n                length "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:q},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:B}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:bj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:q},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"\n                max_length "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bm},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:bn},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:N}]},{type:a,value:" max_length\n"}]}]}]},{type:a,value:g}]},{type:a,value:g}]},{type:a,value:g},{type:b,tag:K,props:{id:aB},children:[{type:b,tag:q,props:{href:"#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",ariaHidden:w,tabIndex:x},children:[{type:b,tag:c,props:{className:[y,z]},children:[]}]},{type:a,value:aC}]},{type:a,value:g},{type:b,tag:bo,props:{id:aD},children:[{type:b,tag:q,props:{href:"#1-%EC%83%81%ED%83%9C%EA%B0%92-%EB%88%84%EC%A0%81-%ED%8A%B8%EB%A6%AC-dfs",ariaHidden:w,tabIndex:x},children:[{type:b,tag:c,props:{className:[y,z]},children:[]}]},{type:a,value:aF}]},{type:a,value:g},{type:b,tag:G,props:{},children:[{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"리프 노드까지 탐색한 다음 부모로 거슬러 올라가면서 각각의 거리를 계산해 상태값(리프 노드에서 현재 노드까지의 거리)을 업데이트하는 방법이다."}]},{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"존재하지 않는 노드에 "},{type:b,tag:s,props:{},children:[{type:a,value:"-1"}]},{type:a,value:"을 부여, 거리는 "},{type:b,tag:s,props:{},children:[{type:a,value:"왼쪽 자식 노드의 상태값 + 오른쪽 자식 노드의 상태값 + 2"}]},{type:a,value:"으로 계산한다.\n"},{type:b,tag:G,props:{},children:[{type:a,value:g},{type:b,tag:r,props:{},children:[{type:b,tag:s,props:{},children:[{type:a,value:ar}]},{type:a,value:"를 더한 이유는 현재 노드와 왼쪽, 오른쪽 자식 노드와의 거리가 "},{type:b,tag:s,props:{},children:[{type:a,value:ar}]},{type:a,value:"이기 때문이다."}]},{type:a,value:g}]},{type:a,value:g}]},{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"중첩 함수("},{type:b,tag:s,props:{},children:[{type:a,value:al}]},{type:a,value:")를 사용할 때 클래스 변수("},{type:b,tag:s,props:{},children:[{type:a,value:bp}]},{type:a,value:")를 사용한 이유\n"},{type:b,tag:G,props:{},children:[{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"중첩 함수에서 부모 함수("},{type:b,tag:s,props:{},children:[{type:a,value:ai}]},{type:a,value:")의 변수를 재할당하면 참조 ID가 변경되어 별도의 로컬 변수로 선언되기 때문이다."}]},{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"단, "},{type:b,tag:s,props:{},children:[{type:a,value:bp}]},{type:a,value:"의 값이 리스트나 딕셔너리라면 굳이 클래스 변수를 사용할 필요가 없다."}]},{type:a,value:g}]},{type:a,value:g}]},{type:a,value:g}]},{type:a,value:g},{type:b,tag:aL,props:{},children:[{type:a,value:g},{type:b,tag:aM,props:{},children:[{type:a,value:aN}]},{type:a,value:g},{type:b,tag:Q,props:{markdown:R},children:[{type:a,value:g},{type:b,tag:Q,props:{className:[aO]},children:[{type:b,tag:aP,props:{className:[aQ,aR]},children:[{type:b,tag:s,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:S}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:aS}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:H}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:aT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aU},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,V]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,V]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aX},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aZ},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:a_},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:a$},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:" right\n\n        \n"},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:S}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:"Solution1"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"\n    longest"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:X}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:U}]},{type:a,value:"\n\n    "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:H}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:ba},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aj},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ak}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:H}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:aj},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ak}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 존재하지 않는 노드의 상태값은 -1"}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:Z}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:am}]},{type:a,value:" node"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:C},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:N}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:B}]},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:R}]},{type:a,value:at},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 왼쪽, 오른쪽의 각 리프 노드까지 탐색"}]},{type:a,value:"\n            left "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:bq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ao},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"\n            right "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:bq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:bf},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:at},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 가장 긴 경로"}]},{type:a,value:"\n            self"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"longest "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:l}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"longest"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:" left "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aa}]},{type:a,value:" right "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aa}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:ar}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:at},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"# 상태값"}]},{type:a,value:M},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:N}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ao},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aa}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A]},children:[{type:a,value:R}]},{type:a,value:"\n\n        dfs"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:v},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:N}]},{type:a,value:" self"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"longest\n"}]}]}]},{type:a,value:g}]},{type:a,value:g}]},{type:a,value:g},{type:b,tag:K,props:{id:aG},children:[{type:b,tag:q,props:{href:"#%EB%B0%B0%EC%9A%B4-%EC%A0%90",ariaHidden:w,tabIndex:x},children:[{type:b,tag:c,props:{className:[y,z]},children:[]}]},{type:a,value:aH}]},{type:a,value:g},{type:b,tag:bo,props:{id:aI},children:[{type:b,tag:q,props:{href:"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%9C%A0%ED%98%95",ariaHidden:w,tabIndex:x},children:[{type:b,tag:c,props:{className:[y,z]},children:[]}]},{type:a,value:aJ}]},{type:a,value:g},{type:b,tag:"ol",props:{},children:[{type:a,value:g},{type:b,tag:r,props:{},children:[{type:b,tag:au,props:{},children:[{type:a,value:"정 이진 트리 (Full Binary Tree)"}]},{type:a,value:": 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리"}]},{type:a,value:g},{type:b,tag:r,props:{},children:[{type:b,tag:au,props:{},children:[{type:a,value:"완전 이진 트리 (Complete Binary Tree)"}]},{type:a,value:": 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져 있는 트리"}]},{type:a,value:g},{type:b,tag:r,props:{},children:[{type:b,tag:au,props:{},children:[{type:a,value:"포화 이진 트리 (Perfect Binary Tree)"}]},{type:a,value:": 모든 노드가 2개의 자식 노드를 가지고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는, 말 그대로 가장 완벽한(Perfect) 유형의 트리"}]},{type:a,value:g}]},{type:a,value:g},{type:b,tag:K,props:{id:P},children:[{type:b,tag:q,props:{href:"#%EC%B6%9C%EC%B2%98",ariaHidden:w,tabIndex:x},children:[{type:b,tag:c,props:{className:[y,z]},children:[]}]},{type:a,value:P}]},{type:a,value:g},{type:b,tag:G,props:{},children:[{type:a,value:g},{type:b,tag:r,props:{},children:[{type:a,value:"박상길, 『파이썬 알고리즘 인터뷰』, 책만(2020), p390-392.\n"},{type:b,tag:G,props:{},children:[{type:a,value:g},{type:b,tag:r,props:{},children:[{type:b,tag:q,props:{href:"https:\u002F\u002Fwww.onlybook.co.kr\u002Fentry\u002Falgorithm-interview",rel:[ac,ad,ae],target:af},children:[{type:a,value:"도서 정보"}]}]},{type:a,value:g},{type:b,tag:r,props:{},children:[{type:b,tag:q,props:{href:"https:\u002F\u002Fgithub.com\u002Fonlybooks\u002Falgorithm-interview",rel:[ac,ad,ae],target:af},children:[{type:a,value:"GitHub"}]}]},{type:a,value:g}]},{type:a,value:g}]},{type:a,value:g}]}]},text:"\n## 문제 링크\n\nhttps:\u002F\u002Fleetcode.com\u002Fproblems\u002Fdiameter-of-binary-tree\u002F\n\n## 나의 풀이 (풀이 실패)\n\n- 노드의 값이 모두 다른 경우는 별다른 문제가 없지만, 모든 요소의 값이 똑같을 경우 아래 방법으로 해결할 수 없다.\n- ex: `[0, 0, 0, 0, None, None, 0, None, None, None, 0]`\n\n\u003Cdetails\u003E\n\u003Csummary\u003E소스 코드\u003C\u002Fsummary\u003E\n\u003Cdiv markdown=\"1\"\u003E\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass MySolution1:\n    def diameterOfBinaryTree(self, root: TreeNode) -\u003E int:\n        # 리프 노드까지의 모든 경로를 routes 리스트에 저장\n        def dfs(tree, curr_route):\n            if not tree:\n                if curr_route not in routes:\n                    routes.append(curr_route)\n                return\n\n            appended_route = curr_route[:]\n            appended_route.append(tree.val)\n            dfs(tree.left, appended_route)\n            dfs(tree.right, appended_route)\n\n        routes = []\n        dfs(root, [])\n\n        max_length = 0\n        # routes에 존재하는 모든 리프 노드까지의 경로끼리 비교,\n        # 요소의 값이 달라지는 순간부터 이후의 모든 값의 개수를 합산하면\n        # 두 리프 노드의 길이(length)가 됨\n        for i in range(len(routes)):\n            for j in range(i, len(routes)):\n                a, b = routes[i], routes[j]\n                print(a, b)\n\n                for k in range(min(len(a), len(b))):\n                    if a[k] != b[k]:\n                        length = (len(a) - k) + (len(b) - k)\n                        max_length = max(max_length, length)\n                # 리프 노드가 하나만 있을 경우를 위해\n                # 두 노드의 최대 거리를 계산\n                # ex: [1, 2]\n                length = max(len(a), len(b)) - min(len(a), len(b))\n                max_length = max(max_length, length)\n        return max_length\n```\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdetails\u003E\n\n## 문제 풀이\n\n### 1. 상태값 누적 트리 DFS\n\n- 리프 노드까지 탐색한 다음 부모로 거슬러 올라가면서 각각의 거리를 계산해 상태값(리프 노드에서 현재 노드까지의 거리)을 업데이트하는 방법이다.\n- 존재하지 않는 노드에 `-1`을 부여, 거리는 `왼쪽 자식 노드의 상태값 + 오른쪽 자식 노드의 상태값 + 2`으로 계산한다.\n  - `2`를 더한 이유는 현재 노드와 왼쪽, 오른쪽 자식 노드와의 거리가 `2`이기 때문이다.\n- 중첩 함수(`dfs`)를 사용할 때 클래스 변수(`self.longest`)를 사용한 이유\n  - 중첩 함수에서 부모 함수(`diameterOfBinaryTree`)의 변수를 재할당하면 참조 ID가 변경되어 별도의 로컬 변수로 선언되기 때문이다.\n  - 단, `self.longest`의 값이 리스트나 딕셔너리라면 굳이 클래스 변수를 사용할 필요가 없다.\n\n\u003Cdetails\u003E\n\u003Csummary\u003E소스 코드\u003C\u002Fsummary\u003E\n\u003Cdiv markdown=\"1\"\u003E\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n        \nclass Solution1:\n    longest: int = 0\n\n    def diameterOfBinaryTree(self, root: TreeNode) -\u003E int:\n        def dfs(node: TreeNode) -\u003E int:\n            # 존재하지 않는 노드의 상태값은 -1\n            if not node:\n                return -1\n\n            # 왼쪽, 오른쪽의 각 리프 노드까지 탐색\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            # 가장 긴 경로\n            self.longest = max(self.longest, left + right + 2)\n\n            # 상태값\n            return max(left, right) + 1\n\n        dfs(root)\n        return self.longest\n```\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdetails\u003E\n\n## 배운 점\n\n### 이진 트리의 유형\n\n1. **정 이진 트리 (Full Binary Tree)**: 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리\n2. **완전 이진 트리 (Complete Binary Tree)**: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져 있는 트리\n3. **포화 이진 트리 (Perfect Binary Tree)**: 모든 노드가 2개의 자식 노드를 가지고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는, 말 그대로 가장 완벽한(Perfect) 유형의 트리\n\n## 출처\n\n- 박상길, 『파이썬 알고리즘 인터뷰』, 책만(2020), p390-392.\n  - [도서 정보](https:\u002F\u002Fwww.onlybook.co.kr\u002Fentry\u002Falgorithm-interview)\n  - [GitHub](https:\u002F\u002Fgithub.com\u002Fonlybooks\u002Falgorithm-interview)\n",dir:"\u002Fposts\u002F2021\u002F06\u002F15",path:"\u002Fposts\u002F2021\u002F06\u002F15\u002Fleetcode-543",extension:".md",createdAt:"2021-06-15T10:03:46.000Z",updatedAt:"2022-06-26T10:01:49.000Z"},isErrorPage:F,isDarkMode:F,isScrolled:F,isMobile:F,isTablet:F,hasHeaderImage:av,isMobileMenuOpened:F,headerImage:"",perPage:10},serverRendered:av,routePath:"\u002Fposts\u002Fleetcode-543",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:aw},content:{dbHash:"6f5af980"}},colorMode:{preference:br,value:br,unknown:av,forced:F}}}("text","element","span","token","punctuation"," ","\n","operator","(",")","keyword","=","builtin",",",":",".","a","li","code","comment","len","\n        ","true",-1,"icon","icon-link","number","-","\n                ","[","]",false,"ul","def","function",2,"h2","self","\n            ","return","max","출처","div","1","class","class-name","0","boolean","None","int","tree","if","in","b","+","root","nofollow","noopener","noreferrer","_blank","\n    "," right","diameterOfBinaryTree"," TreeNode","\u003E","dfs","not"," routes","left","for","range","2","node","\n\n            ","strong",true,null,"문제-링크","문제 링크","나의-풀이-풀이-실패","나의 풀이 (풀이 실패)","문제-풀이","문제 풀이","1-상태값-누적-트리-dfs",3,"1. 상태값 누적 트리 DFS","배운-점","배운 점","이진-트리의-유형","이진 트리의 유형","https:\u002F\u002Fleetcode.com\u002Fproblems\u002Fdiameter-of-binary-tree\u002F","details","summary","소스 코드","nuxt-content-highlight","pre","language-python","line-numbers","TreeNode","__init__"," val"," left","\n        self","val "," val\n        self","left "," left\n        self","right "," root"," curr_route","append","\n            dfs"," appended_route","right","routes","i"," b","min","k"," k","max_length"," length","h3","self.longest"," dfs","system"));